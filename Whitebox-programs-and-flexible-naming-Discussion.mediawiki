===Proposal===
Extend the Gobo naming policy for packages in a backwards-compatible way, to allow the introduction of heavily patched packages and imported packages from other distros, while avoiding naming conflicts. At the same time, avoid naming conflicts related to user-contributed packages. 

===Rationale===

It's part of the Gobo policy to avoid excessive patching, among other reasons because it is annoying for users (who don't know whether a bug is caused by the original program or the patched version) and arguably a kind of disrespect for the developers of the application, since a different product is distributed under the same name. This can even bring about legal problems, as seen in the Debian-Mozilla affair with Firefox. It's crucial to distinguish copyright from trademark. A GPL'd program can be freely modified, but there may be a strict policy about how the modified versions should be called. I contend that a careful naming policy can facilitate the creation of a rich variety of modified (patched) versions of popular programs, while strictly respecting trademarks.
<br>
The proposed strategy involves the creation of "whitebox" versions of every package. A whitebox version in this context is a version of the package where all the icons and other trademarked material is removed and replaced by trivial, quick-and-dirty substitutes, unencumbered by trademarks. For instance, Firefox icons could be replaced by blank icons of the same size of the originals. The icon with the Firefox name would be replaced by "Firefox-based,not Firefox" or something like that. The process should be easy to automate through a script. The point of this is to then take the whitebox version and patch it to replace the whitebox icons with trademark-unencumbered icons, chosen by gobo users. Some packages don't have this problem, and their icons can be freely edited. These packages should be tagged as "original" and not whiteboxed (since this is not necessary), while those encumbered by trademarks should be tagged as "trademarked". Untagged packages would be assumed to be not-yet classified.
<br>


A different objection is often raised about excessive patching: it requires extensive distro-specific hosting and bandwidth. Gobolinux strategy to reduce bandwidth requirements has been to outsource the download. Recipes take the url of each project, instead of a central Gobolinux repository. While this is a smart move, and very useful in most cases, it cannot be applied to Gobo-specific patches that can't be submitted upstream. 

I contend that, in the long run, every distro needs to own some repositories for distro-specific customizations. In the Linux world, this kind of customizations make a distro special for its users. The natural place for integration between different programs is the distribution, and sometimes it needs to override the disagreements between different projects (applications) if it wants to get this integration for its users. This should not involve making users over-dependent of the distro, in the sense that they should be able to download and compile programs not-yet integrated in the distro, without difficulty, as they do right now in Gobolinux. My point is that we can have the best of both worlds with a good naming policy.

So, what could be the way to get cheap distro-specific hosting? My bet is to use p2p technologies, such as Bittorrent, so that users contribute storage and bandwidth. An interesting distro I've seen that uses this approach is Heretix (previously called Rubyx). It seem's to be momentarily inactive but not dead, and it's been using a program called WhiteWater, which is like Bittorrent but more specifically adapted to the creation of distributed repositories. I think we should take a look at them and maybe ask some question. But this is for another "idea" article.


===Basic strategy===

====Two additional characters====
Add two ASCII characters not currently used in package names. We'll use "<" and ">" for this explanation, but any others would do, as long as readability is preserved. They should be a pair of simmetric, open-close characters.

====Arbitrary names====
Mark the end-of-name at the beginning, with a square-bracketed number, which is as high as necessary (explained later) to allow arbitray package names.

====Lisp-like syntax====
Make new package names based on old names of packages and (possibly) patches, by nesting them in bigger names. The syntax would be lisp-like, that is, fully bracketed prefix notation, but with keywords acting as brackets and spaces.

===Notation===
<nowiki>
"<B>": beginning (opening bracket, "(" )</nowiki><br>
<nowiki>
"<E>": end (closing bracket, ")" )</nowiki><br>
<nowiki>
"<S>": space between tokens</nowiki><br>
<nowiki>
"_": space inside a token</nowiki><br>
<nowiki>
"<N>["+<number>+"]": beginning of a token with arbitrary characters inside. The end is marked by "["+<number>+"]". For instance "<N>[1]PackageName[1]"</nowiki><br>

===Basic package names===


We will take two example packages: Firefox-2.0 and Iceweasel-1.0. Let's assume Firefox is trademarked and Iceweasel is original.

The package names would be:

<nowiki><B><N>[1]Firefox-2.0[1]<E></nowiki><br>
<nowiki><B><N>[1]Iceweasel-1.0[1]<E></nowiki><br>

This allows arbitrary package names. If the package names includes a "[1]", then "<N>[2]" would be used instead, and so on. This can be automated by a script.

===Original, trademarked and whiteboxed packages===


Now we know Iceweasel is original, so we create the package name:

<nowiki><B>o<S><N>[1]Iceweasel-1.0[1]<E>.</nowiki><br>

Another way to say the same package name would be 

<nowiki><B>original<S><N>[1]Iceweasel-1.0[1]<E></nowiki><br>

and yet another, more verbose way:
<nowiki>
<B>original_version<S><N>[1]Iceweasel-1.0[1]<E>.</nowiki><br>

As said above, the "S" marks a space to separate tokens, and the "_" marks a space inside a token.
The first form is the least verbose, so it should be preferred.


The Compile script knows these three names are equivalent, just that the "o" informs that the package is "original" (not "trademarked"), so it can be directly patched.



Firefox, instead, is trademarked. It must be whiteboxed before extensive patching. So, we create the package name:

<nowiki><B>t<S><N>[1]Firefox-2.0[1]<E></nowiki><br>

Or:

<nowiki><B>trademarked<S><N>[1]Firefox-2.0[1]<E></nowiki><br>

Or:

<nowiki><B>trademarked_version<S><N>[1]Firefox-2.0[1]<E></nowiki><br>

And then, when the whitebox version (marked with a "w") is ready, this new version will be called:

<nowiki><B>w<S><N>[1]Firefox-2.0[1]<E></nowiki><br>

(we'll ommit longer names from now on, except when necessary)

===Locally compiled packages===

Let's say a user (called "martin" in his local machine, and "Martin Baldan" as a registered Gobolinux user)  compiled Firefox-2.0 locally. In his machine it would appear as:

<nowiki><B>l<S><N>[1]martin[1]<S><B>t<S><N>[1]Firefox-2.0[1]<E><E></nowiki><br>

The "l" is for local, meaning that this name is only valid in his computer, not an official name of a Gobo package.

So, the user can distinguish at first sight which packages have been compiled by him and which packages have been directly installed with InstallPackage. The shell can be configured to ommit this distinction if the user wants it, but it's quite useful that the system knows.

When his recipe is uploaded to Gobolinux as a contributed recipe, it is renamed as:

<nowiki><B>u<S><N>[1]Martin_Baldan[1]<S><B>t<S><N>[1]Firefox-2.0[1]<E><E></nowiki><br>

Where "u" is for "user" and "Martin_Baldan" is the user's registered name.

===Locally patched packages===


Let's say Martin patches the whitebox version of firefox with patches patch1 and patch2.We assume that there's a patch repository.

In his computer, the new package would appear as:

<nowiki><B>l<S><N>[1]martin[1]<S>p<S><B>w<S><N>[1]Firefox-2.0[1]<E><S>patch1<S>patch2<E></nowiki><br>

The "p" is for "patch".

They must be compatible patches, that is, they don't try to overwrite each other and can be applied in any order. If another patch, patch3, needs to be applied after patch1 and patch2, then this fact would be reflected as nested patching:

<nowiki><B>l<S><N>[1]martin[1]<S>p<S><B>p<S><B>w<S><N>[1]Firefox-2.0[1]<E><S>patch1<S>patch2<E><S>patch3<E></nowiki>
<br>
This nested notation may be inconvenient if there's a long list of incompatible (order-dependent) patches. Let's say we have such a list: patch1, patch2, patch3, patch4 must be applied in this order. For this kind of situation, we have "sp" (serial patching):

<nowiki><B>l<S><N>[1]martin[1]<S>sp<S><B>w<S><N>[1]Firefox-2.0[1]<E><S>patch1<S>patch2<S>patch3<S>patch4<E></nowiki>
<br>

===User-contributed patched packages. Recipes for patched versions and patch-recipes===


Let's say Martin submits his patched version to Gobo developers, and it is accepted. The patches would be incorporated in the new recipe, and the name of this official patched packaged would be:

<nowiki><B>p<S><B>w<S><N>[1]Firefox-2.0[1]<E><S>patch1<S>patch2<E></nowiki><br>

Now let's say there's not much room for so many patched packages, not even for so many recipes holding the body of the patches (there are ways to get more storage and bandwidth, as I said above, but's that's another topic). They can instead provide a "patch recipe" which only gives the names of the patches, which are to be fetched in the patch repo. A package built from a patch-recipe would have this name:
<nowiki>
<B>pr<S><B>w<S><N>[1]Firefox-2.0[1]<E><S>patch1<S>patch2<E></nowiki><br>

With the "pr" indicating it was built from a patch recipe (a serial patch recipe may be indicated by "spr"). But this is an official package. How about a locally-compiled package, from an official patch recipe?

<nowiki><B>l<S><N>[1]martin[1]<S><B>pr<S><B>w<S><N>[1]Firefox-2.0[1]<E><S>patch1<S>patch2<E><E>
</nowiki><br>

Now let's say the user made a new patch all of himself, and he called it "pacho". There's a directory for locally created patches. The user can tell Compile where his local patches are, in a configuration file. Let's say pacho is compatible with the official patches patch1 and patch2. Now the locally compiled package looks like:

<nowiki><B>l<S><N>[1]martin[1]<S>p<S><B>w<S><N>[1]Firefox-2.0[1]<E><S>patch1<S>patch2<S><B>l<S><N>[1]pacho[1]<E><E>
</nowiki><br>

Now let's say this "pacho" is quite good, and martin's patched version is accepted in the official gobo, but just as a user-contributed patch recipe. Its name will be:

<nowiki><B>u<S><N>[1]Martin_Baldan[1]<S>p<S><B>w<S><N>[1]Firefox-2.0[1]<E><S>patch1<S>patch2<S><B>l<S><N>
[1]pacho[1]<E><E></nowiki><br>

===packages from other distros (imported packages)===


Now let's say there's another distro called Patchuntu, which patches heavily its packages, and, of course, has a different naming convention. Let's say it has a very good patched version of Iceweasel (this is not possible with Firefox, for trademark reasons). What if gobo users want to bring this version to Gobolinux? Well, that's easy, just call it like this:

<nowiki><B>i<S><N>[1]Patchuntu-6.0[1]<S><N>[1]IceWeeesel-whocaresversion[1]<E>
</nowiki><br>

Where "i" is for "import".

Notice that I don't mean a package from another distro, say a ".deb" or a ".rpm" can be directly used in Gobolinux. What I say is that Gobo developers take the package, extract the modified source and build a Gobo package.

===Meta-versioning (to fix a broken versioning system or restart a bloated one)===


But these guys at Patchuntu are so careless that they release a new patched version of IceWeasel, which is even better, but they don't even bother to change the name. What if gobo users want this second version as well, and don't want to bring the naming conflict with it? Then the second version would be called:

<nowiki><B>i<S><N>[1]Patchuntu-6.0[1]<S><B>v<S>2<S><N>[1]IceWeeesel-whocaresversion[1]<E><E>
</nowiki><br>

Where "v" is for "version". Notice that this strategy applies whenever the versioning system breaks, so it can also be useful as first aid for gobo patches and scripts.
For instance, let's say we are in Gobolinux-777 and the Scripts package has a name like this:

<nowiki><B><N>[1]Scripts-99999999999999999999999999999999[1]<E></nowiki><br>

So, Gobo developers decide that it may be convenient to start anew with the version numbers. But then, if there's a new Scripts-1, it should be wise to have a way to distinguish it from the old Scripts-1. The way to do that may be to rename the old Scripts-1 in this way:

<nowiki>old name: <B><N>[1]Scripts-1[1]<E></nowiki><br>
<nowiki>new name: <B>v<S>1<S><N>[1]Scripts-1[1]<E></nowiki><br>